#' Determine whether sequencing reads in fact support DBSs generated by processing a VCF file.
#'
#' @param input.vcf.name The name of the VCF file to analyze. The VCF file can be gzip'ed.
#'
#' @param Nbam.name The name of the BAM file for the normal sample corresponding to \code{vcf.name}.
#'
#' @param Tbam.name The name of the BAM file for the tumor sample corresponding to \code{vcf.name}.
#'
#' @param variant.caller One of \code{"strelka"}, \code{"mutect"}, \code{"PCAWG"}, or \code{"unknown"}.
#'  If \code{variant.caller} is \code{"unknown"}, then the variant caller must have called
#'  DBSs as such. For \code{"strelka"} and {"mutect"} DBS analysis is as in \code{ICAMS};
#'  Strelka does not call DBSs, and DBSs are inferred from adjacent single base substitutions.
#'  This is the case for \code{"PCAWG"} as well.
#'
#' @param num.cores Number of cores to use while reading the VCF. Set this to 1 for testing
#'  and on MS Windows.
#'
#' @param N.slice.dir Directory for the slices of the normal BAM.
#'  Created if necessary.
#'
#' @param T.slice.dir Directory for the slices of the tumor BAM.
#'  Created if necessary. Must be different than \code{N.slice.dir}.
#'
#' @param unlink.slice.dir If \code{TRUE} unlink \code{N.slice.dir} and \code{T.slice.dir} before return.
#'
#' @param outfile If not \code{NULL} then write the "evaluated" VCF to \code{outfile};
#'  otherwise write it to \code{paste0(vcf.name, "_evaluated.vcf")}.
#'
#' @param verbose If > 0 print a message when starting the number of slices
#'    generated every \code{verbose} slices.
#'
#' @details Creates a new VCF file.
#'  The additional information in this VCF files is described in \code{\link{VerifyDBSVcf}}.
#'
#' @return Invisibly, a list with the elements
#'
#' 1. The name of the VCF file created
#'
#' 1. The in-memory representation of the VCF as a \code{data.table}
#'
#' 1. The directory with the normal sam slices, if \code{unlink.slice.dir} is \code{FALSE}.
#'
#' 1. The directory with the tumor sam slices, if \code{unlink.slice.dir} is \code{FALSE}.
#'
#' @md
#' @export
#'

ReadVCFAndBAMsAndVerifyDBSs <- function(input.vcf.name,
                                        Nbam.name,
                                        Tbam.name,
                                        variant.caller,
                                        num.cores        = 10,
                                        N.slice.dir      = tempfile(),
                                        T.slice.dir      = tempfile(),
                                        unlink.slice.dir = TRUE,
                                        outfile          = NULL,
                                        verbose          = 0) {

  CheckBAM(Nbam.name)
  CheckBAM(Tbam.name)
  TestBAMAndSamtools(Nbam.name)
  TestBAMAndSamtools(Tbam.name)
  if (N.slice.dir == T.slice.dir) {
    stop("T.slice.dir and N.slice.dir must be different; got ",
         N.slice.dir)
  }

  if (!file.exists(input.vcf.name)) {
    stop("VCF file ", input.vcf.name, "does not exist")
  }

  if (variant.caller %in% c("strelka", "mutect", "unknown")) {
    get.vaf.function <- NULL
  } else if (variant.caller == "PCAWG") {
    variant.caller <- "unknown"
    get.vaf.function <- GetPCAWGVAF
  }

  vcf.list <-ICAMS::ReadAndSplitVCFs(input.vcf.name,
                                     variant.caller = variant.caller,
                                     num.of.cores   = num.cores,
                                     get.vaf.function = get.vaf.function,
                                     max.vaf.diff   = 1)

  DBS.vcf <- vcf.list$DBS[[1]]

  if (verbose > 0) {
    message("Analyzing vcf            ", input.vcf.name)
    message("Normal BAM               ", Nbam.name)
    message("Tumor BAM                ", Tbam.name)
    message("Ouput evaluated VCF file ", outfile)
  }

  if (nrow(DBS.vcf) == 0) {
    message("No DBSs found in ", input.vcf.name)
    evaluated.vcf <- DBS.vcf
  }


  evaluated.vcf <- VerifyDBSVcf(DBS.vcf,
                                Nbam.name = Nbam.name,
                                Tbam.name = Tbam.name,
                                N.slice.dir = N.slice.dir,
                                T.slice.dir = T.slice.dir,
                                verbose     = verbose)

  if (is.null(outfile)) {
    outfile <- paste0(input.vcf.name, "_evaluated.vcf")
  }

  cat("#", file = outfile)
  suppressWarnings(
    utils::write.table(
      evaluated.vcf,
      file = outfile,
      sep="\t",
      quote = FALSE,
      row.names = FALSE,
      append = TRUE))


  if (unlink.slice.dir) {
    unlink(N.slice.dir, recursive = TRUE)
    unlink(T.slice.dir, recursive = TRUE)
    N.slice.dir <- NA
    T.slice.dir <- NA
  }

  invisible(list(evaluated.vcf.name = outfile,
                 evaluated.vcf      = evaluated.vcf,
                 N.slice.dir        = N.slice.dir,
                 T.slice.dir        = T.slice.dir))
}
